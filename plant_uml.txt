@startuml
package neat_net {
  class Genome {
  + n_in: int
  + n_out: int
  + recurrent: bool
  + verbose: bool
  + allowed_act_funcs: str []
  - node_genes: dict []
  - conn_genes: dict []
  }

  class NNFF {
  + genome: Genome
  + layers: int [][]
  + feedforward(): int []
  - get_layers_ff(): int [][]
  - get_layer_info(): dict []
  }
}

package population {
  class Population {
  + popsize: int
  - this_gen: Genome []
  - fitness_assesor: FitnessAssesor
  - create_first_gen(): Genome []
  + run()
  }
  note right of Population: `fitness_assesor.run(this_gen)` is called in a loop

  interface FitnessAssesor {
  + run(genomes: Genome []): float []
  }
  class InteractiveFitness
  class PixelDiffFitness
}



package image_cppn {
  class CPPN {
  - net: NNFF
  + create_image(): Image
  }
  class Image
  hide Image members
}


package tk_display {
class ImgGrid {
  - images: Image []
  + run(): float []
  }
}

' alternative way of doing things using functions
class FitFunc << (F,orchid) Function<Genome[],int[]> >>
hide FitFunc members
class InteractiveFitFunc << (F,orchid) Function<T,TResult> >>
hide InteractiveFitFunc members
FitFunc <|-- InteractiveFitFunc
note top of FitFunc: Possible alternative way of modelling using Functions??

' define relationships
CPPN "1" *-- "1" NNFF
NNFF "1" *-- "1" Genome
Population "1" *-- "n" Genome
Population "1" *-- "1" FitnessAssesor
FitnessAssesor <|-- InteractiveFitness
FitnessAssesor <|-- PixelDiffFitness
InteractiveFitness "1" *-- "1" ImgGrid
ImgGrid "1" *-- "n" Image
Image .. CPPN : generated by >
@enduml
